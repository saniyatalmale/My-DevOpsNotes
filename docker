# ğŸ³ Complete Docker Theory Guide (DCA-Aligned)

This guide is designed for both **Docker Certified Associate (DCA) exam preparation** and **real-world engineering architecture**. Each section includes:

- ğŸ“Œ What it is
- ğŸ”§ Alternatives & comparison
- âœ… Pros & âŒ Cons
- ğŸ›  Best practices
- ğŸ“¦ Real-world examples
- ğŸ§  Rules of thumb or decision tables

---

## ğŸ”¹ 1. Why use Docker

### ğŸ“Œ What is it?

Docker is a containerization platform that allows you to package an application and its dependencies into a single, portable unit called a **container**.

### ğŸ”§ What else is used instead?

| Alternative           | Common Use Case                         | Limitations                                         |
|-----------------------|------------------------------------------|-----------------------------------------------------|
| Virtual Machines (VMs) | OS-level isolation                      | Heavier, slower boot, more resource use             |
| Bare-metal installs    | Legacy / high-perf systems              | Hard to replicate or migrate                        |
| Serverless (Lambda)    | Stateless, event-driven workloads       | Unsuitable for complex/stateful apps                |
| PaaS (e.g. Heroku)     | Simplified app deployment               | Vendor lock-in, limited control                     |

### âœ… Pros

- âš¡ Fast boot times
- ğŸ“¦ Portability across environments
- ğŸ§ª Great for CI/CD and testing
- ğŸš€ Optimized for microservices
- ğŸ” Lightweight & efficient

### âŒ Cons

- ğŸ” Shared kernel (not full isolation)
- ğŸ“‚ Ephemeral storage
- ğŸ“ˆ Requires orchestration at scale

### ğŸ“Œ When to use Docker

| Use Case                  | Containers | VMs   | Serverless | Bare Metal |
|---------------------------|------------|-------|------------|------------|
| Web/Microservices         | âœ… Best    | âš ï¸ OK | âš ï¸ Stateless only | âŒ No       |
| Stateful apps             | âš ï¸ Volume mgmt | âœ… Best | âŒ No       | âœ… OK       |
| Custom kernel modules     | âŒ No      | âœ… Yes| âŒ No       | âœ… Yes      |

### ğŸ§  Rule of Thumb

Use Docker when you need **portability, speed, and consistency** across environments. Use VMs for full OS control, and serverless for short-lived logic.

---

## ğŸ”¹ 2. Dockerfile

### ğŸ“Œ What is it?

A `Dockerfile` is a declarative script that defines how an image is built using layers of instructions like `FROM`, `COPY`, `RUN`, and `CMD`.

### ğŸ”§ What else is used?

| Alternative        | Drawback                                  |
|--------------------|--------------------------------------------|
| Manual image setup | Not reproducible                           |
| Shell scripts      | Not container-native                       |
| Prebuilt images    | No customization                           |

### âœ… Pros

- ğŸ“œ Declarative, trackable
- ğŸ’¾ Layer caching improves builds
- ğŸ” Customizable dependency chain

### âŒ Cons

- ğŸ› Easy to bloat images
- ğŸ§© Debugging can be hard

### ğŸ“¦ Example

```dockerfile
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
CMD ["python", "app.py"]
```

### ğŸ›  Best Practices

- Use minimal base images
- Pin versions
- Optimize layer order
- Use `.dockerignore`

### ğŸ“Œ When to use

| Scenario                          | Use Dockerfile? |
|----------------------------------|-----------------|
| Custom build steps               | âœ… Yes          |
| Reusing existing images          | âŒ No           |
| CI/CD controlled builds          | âœ… Yes          |

### ğŸ§  Rule of Thumb

Use Dockerfile for **custom images**, especially when reproducibility or CI/CD integration is important.

---

## ğŸ”¹ 3. Building Images

### ğŸ“Œ What is it?

The process of converting a `Dockerfile` into a runnable container image using the `docker build` command. The image is composed of read-only layers defined by each Dockerfile instruction.

Note: You can partially reverse-engineer a Dockerfile from a container image, but **you will never get the original Dockerfile exactly as written**

### ğŸ”§ What else is used?

| Alternative        | Drawback                                |
|--------------------|------------------------------------------|
| Manual container snapshots | Not reproducible                 |
| Base-only images           | No application logic included    |

### âœ… Pros

- ğŸ“¦ Reproducible build artifacts
- ğŸš€ Layer caching accelerates rebuilds
- ğŸ” Precise control of base and dependencies

### âŒ Cons

- ğŸ˜ Large image size if not optimized
- ğŸ”„ Cache invalidation can be tricky

### ğŸ“¦ Example

```bash
docker build -t myapp:latest .
```

### ğŸ›  Best Practices

- Use multi-stage builds
- Tag images with version/hash
- Use `--no-cache` for clean rebuilds when needed

### ğŸ“Œ When to use

| Use Case                        | Build Images? |
|----------------------------------|---------------|
| Production deployment            | âœ… Yes        |
| Dev-only containers              | âœ… Usually    |
| Using fully prebuilt base apps   | âŒ No         |

---

## ğŸ”¹ 4. Running Containers

### ğŸ“Œ What is it?

Launching a container from a built image using `docker run`, optionally defining volumes, ports, environment variables, and network behavior.

### ğŸ”§ What else is used?

| Alternative     | Drawback                          |
|-----------------|------------------------------------|
| VM snapshots    | Heavy and inflexible               |
| Manual process  | No reproducibility                 |

### âœ… Pros

- âš™ï¸ Rapid start/stop
- ğŸ§ª Ideal for test/dev cycles
- ğŸ” Easily restarted or scaled

### âŒ Cons

- âš ï¸ Volatile filesystem unless volumes used
- ğŸ§© Limited persistent service management without orchestration

### ğŸ“¦ Example

```bash
docker run -d -p 8080:80 myapp:latest
```

### ğŸ›  Best Practices

- Use `--rm` for ephemeral use
- Use `-d` for detached mode
- Use `--name` for container naming

### ğŸ“Œ When to use

| Scenario                  | Use docker run? |
|---------------------------|-----------------|
| Testing image locally     | âœ… Yes          |
| Permanent services        | âš ï¸ Use Compose/Swarm |
| Running one-off scripts   | âœ… Ideal        |

---

## ğŸ”¹ 5. Logs

### ğŸ“Œ What is it?

Docker provides logging through the containerâ€™s stdout/stderr streams, viewable via `docker logs`.

### ğŸ”§ What else is used?

| Alternative       | Limitation                          |
|-------------------|--------------------------------------|
| Syslog/Nginx logs | Not container-aware                  |
| File-based logs   | Not standardized across containers   |

### âœ… Pros

- ğŸ” Easy to access (`docker logs <container>`)
- ğŸ”— Streamed to logging drivers

### âŒ Cons

- ğŸ“ Logs lost on container delete (unless persisted)
- â›” Log size growth not managed by default

### ğŸ“¦ Example

```bash
docker logs myapp_container
```

### ğŸ›  Best Practices

- Use log rotation
- Forward logs to central logging systems (e.g. ELK, Loki)

### ğŸ“Œ When to use

| Logging Type       | Use Docker logs? |
|--------------------|------------------|
| Dev debugging       | âœ… Ideal         |
| Production logging  | âš ï¸ Needs forwarder |
| Stateful apps       | âš ï¸ Persist logs  |

---

## ğŸ”¹ 6. Inspecting

### ğŸ“Œ What is it?

Using `docker inspect` or `docker ps` to examine container/image metadata (network, mounts, runtime config, etc.)

### ğŸ”§ What else is used?

| Alternative     | Drawback                         |
|-----------------|-----------------------------------|
| Manual config   | Not introspectable                |
| Monitoring tools| High-level view only              |

### âœ… Pros

- ğŸ§  Deep introspection of objects
- âš™ï¸ Useful for debugging, scripting

### âŒ Cons

- ğŸ§¾ JSON-heavy output
- ğŸ§© Not user-friendly without formatting

### ğŸ“¦ Example

```bash
docker inspect myapp_container
docker ps -a
```

### ğŸ›  Best Practices

- Use `--format` for parsing
- Combine with `jq` or shell scripts for automation

Some examples:

Get the container's IP address:
>docker inspect my_container | jq -r '.[0].NetworkSettings.IPAddress'

List all environment variables
>docker inspect my_container | jq -r '.[0].Config.Env[]'

List mounted volumes (host path â†’ container path)
>docker inspect my_container | jq -r '.[0].Mounts[] | "\(.Source) â†’ \(.Destination)"'

Get the ENTRYPOINT and CMD
>docker inspect my_container | jq -r '.[0].Config.Entrypoint, .[0].Config.Cmd'

Get published ports and mappings
>docker inspect my_container | jq -r '.[0].NetworkSettings.Ports'

**Bash automation scripts:**

List all running containers with their base images
```
for id in $(docker ps -q); do
  name=$(docker inspect --format '{{.Name}}' $id | sed 's/\///')
  image=$(docker inspect --format '{{.Config.Image}}' $id)
  echo "$name uses image $image"
done
```

Get image size of each container (via history)
```
for img in $(docker ps --format '{{.Image}}'); do
  echo "Inspecting $img"
  docker history $img | awk '{print $1, $2, $3, $4}'
done
```

Summarize how many containers use each base image
```
docker ps -a --format '{{.Image}}' | sort | uniq -c
```

Warn if container uses `latest` tag
```
docker ps --format '{{.Image}}' | grep ':latest' && echo "â— Some containers use latest â€” not recommended"
```

Create an audit log of all running containers
```
timestamp=$(date +%Y%m%d_%H%M%S)
mkdir -p audits
for id in $(docker ps -q); do
  docker inspect $id > audits/${id}_${timestamp}.json
done
```

### ğŸ“Œ When to use

| Use Case                    | Use inspect? |
|-----------------------------|--------------|
| Debugging networking issues | âœ… Yes       |
| Monitoring deployments      | âœ… Yes       |
| End-user troubleshooting    | âš ï¸ Too technical |

---

## ğŸ”¹ 7. Process ID (PID 1)

### ğŸ“Œ What is it?

In Docker, the main application process inside a container always runs as **PID 1**. This has implications for **signal handling** and **process reaping**.

### ğŸ”§ What else is used?

| Alternative | Drawback                      |
|-------------|-------------------------------|
| Supervisor/init system in VMs | Overhead in containers         |

### âœ… Pros

- ğŸ“Œ Clear entrypoint for containers
- ğŸ”§ Control over lifecycle

### âŒ Cons

- âš ï¸ PID 1 ignores some signals (e.g. SIGTERM)
- âš ï¸ Orphaned zombie processes if not reaped

### ğŸ“¦ Example

```dockerfile
CMD ["python", "app.py"]
```

### ğŸ›  Best Practices

- Use a process manager like `tini` or `dumb-init`
- Trap and forward signals in shell scripts

### ğŸ“Œ When to care

| Scenario                     | PID 1 Matters? |
|-----------------------------|----------------|
| Graceful shutdown handling  | âœ… Yes         |
| Multi-process containers    | âœ… Yes         |
| Simple dev/test container   | âš ï¸ Maybe       |

---

## ğŸ”¹ 8. Volumes

### ğŸ“Œ What is it?

Docker **volumes** are persistent storage objects managed by Docker, mounted into containers at runtime. They are **decoupled from the container lifecycle**, meaning data persists even after the container is removed.

### ğŸ”§ What else is used?

| Method               | What It Is                        | When to Use                           | Limitations                           |
| -------------------- | --------------------------------- | ------------------------------------- | ------------------------------------- |
| **Named volumes**    | Docker-managed persistent volumes | ğŸŸ¢ Best for most stateful containers  | Must be managed via Docker CLI/API    |
| **Bind mounts**      | Host path mapped into container   | ğŸŸ  Good for dev/test with local files | Not portable; tied to host filesystem |
| **tmpfs**            | RAM-only mount inside container   | ğŸŸ  In-memory caching or secrets       | Data disappears on container restart  |
| **External drivers** | e.g., NFS, EBS, Ceph via plugin   | ğŸŸ¢ Multi-host shared volume scenarios | Needs plugin, network latency         |
### âœ… Pros

- ğŸ’¾ Data persists across container restarts and re-creates
    
- ğŸ” Separation of data and app logic = easier upgrades
    
- ğŸ“¦ Optimized by Docker for cross-platform performance
    

### âŒ Cons

- ğŸ§¹ Volume cleanup requires explicit commands (`docker volume rm`)
    
- âš ï¸ File permissions can be misaligned (UID/GID mismatches)
    
- ğŸ§± Complex setups (NFS, CIFS) need Docker volume plugins

### ğŸ“¦ Example

```bash
docker volume create db-vol
docker run -v db-vol:/var/lib/mysql mysql
```

Or with bind mounts:
```
docker run -v /home/user/config:/app/config myapp
```

### ğŸ›  Best Practices

| Use Case                        | Recommendation                             |
| ------------------------------- | ------------------------------------------ |
| **Databases, uploads, logs**    | âœ… Use named volumes (portable, managed)    |
| **Development with host files** | âš ï¸ Use bind mounts (host-path â†” container) |
| **Secrets in memory**           | âš ï¸ Use `tmpfs` volumes                     |
| **Multi-node clusters**         | âœ… Use volume plugins or Kubernetes PVCs    |
### ğŸ“Œ When to use

| Scenario                      | Use Named Volumes? | Use Bind Mounts? | Use tmpfs? |
| ----------------------------- | ------------------ | ---------------- | ---------- |
| Persist MySQL data            | âœ… Yes              | âŒ No             | âŒ No       |
| Mount config files during dev | âš ï¸ Maybe           | âœ… Yes            | âŒ No       |
| Store in-memory session cache | âŒ No               | âŒ No             | âœ… Yes      |


### ğŸ”¹ How Named Volumes Work in Docker

#### ğŸ“Œ What happens when you create a named volume?

```bash
docker volume create db-vol
```

Docker creates an entry in its **volume store**, typically at:

```
/var/lib/docker/volumes/db-vol/_data
```

This path is **abstracted** â€” Docker manages it internally.

---

#### ğŸ“¦ How it's mounted in a container

```bash
docker run -v db-vol:/var/lib/mysql mysql
```

Docker performs:

1. **Lookup** for `db-vol` in its volume store.
2. **Mounts** `/var/lib/docker/volumes/db-vol/_data` to `/var/lib/mysql` in the container.
3. **Manages** access, lifecycle, and cleanup.

---

#### ğŸŒ Why it's considered portable

Named volumes are:
- Declared in `docker run`, `docker-compose.yml`, or Swarm YAML.
- Always refer to **Docker-managed locations**, regardless of host OS.
- Cross-platform: works on Linux, macOS, WSL, and Docker Desktop.

You can `docker-compose up` on any machine â€” Docker handles the storage behind `db-vol`.

---

#### ğŸ” Inspecting the backing path

```bash
docker volume inspect db-vol
```

Example output:
```json
{
  "Name": "db-vol",
  "Driver": "local",
  "Mountpoint": "/var/lib/docker/volumes/db-vol/_data"
}
```

---

#### ğŸ›  Custom volume location (advanced)

You can override the storage path using `driver_opts` in Compose:

```yaml
volumes:
  db-vol:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/fast-disk/mysql-data
```

This creates a volume mounted from a custom host folder.

---

#### âœ… Summary Table

| Feature                     | Named Volumes     | Bind Mounts         |
|----------------------------|-------------------|---------------------|
| Path management            | Docker-managed    | You specify path    |
| Portability                | âœ… High           | âŒ Host-dependent    |
| Lifecycle with containers  | Independent       | Independent         |
| Permissions handling       | Docker-managed    | Must match host UID |
| Cross-platform consistency | âœ… Yes            | âŒ No                |

---

#### ğŸ§  DCA Exam Tip

> âœ… Named volumes are best for production data because they're host-agnostic, Docker-managed, and automatically provisioned.


---

## ğŸ”¹ 9. Networking

### ğŸ“Œ What is it?

Docker provides virtual networks (bridge, overlay, host) to connect containers and expose services.

### ğŸ”§ What else is used?

| Alternative    | Limitation                      |
|----------------|----------------------------------|
| Host networking| No isolation                    |
| Manual IPs     | No automation                   |

### ğŸ”§ What options exist?

| Network Driver | Description                            | Use Case                                      | Limitations                                |
| -------------- | -------------------------------------- | --------------------------------------------- | ------------------------------------------ |
| **bridge**     | Default for standalone containers      | ğŸŸ¢ Best for single-host, custom microservices | âŒ Doesnâ€™t work across hosts                |
| **host**       | Container shares host network stack    | âš ï¸ Low-latency apps (e.g., DNS servers)       | âŒ No isolation; port conflicts             |
| **overlay**    | Virtual network across Swarm/K8s nodes | ğŸŸ¢ Multi-host communication via Swarm         | Requires Swarm mode or orchestration setup |
| **macvlan**    | Assigns MAC address on the local LAN   | ğŸŸ  Legacy apps needing real IPs               | Complex setup; breaks DNS-based discovery  |
| **none**       | No networking                          | ğŸ”’ Air-gapped or IPC-only containers          | No communication even with host            |

### âœ… Pros

- ğŸŒ Built-in DNS resolution by container name
    
- ğŸ”’ Isolation between user-defined networks
    
- ğŸ” Cross-container communication made easy
    

### âŒ Cons

- âš ï¸ Default bridge limits are non-trivial (manual port mapping, no DNS unless defined in a user-defined bridge network)
    
- ğŸ§± Overlay networks need Swarm init and gossip protocol
    
- ğŸ§ª Network plugins (CNI) not supported natively in Docker CE (K8s needed)

### ğŸ“¦ Example

User-defined bridge with DNS support:

```bash
docker network create app-net
docker run -d --network app-net --name db postgres
docker run -d --network app-net --name app myapp  # app can resolve 'db'
```

Overlay in Swarm:

```bash
docker network create -d overlay web-overlay
docker service create --network web-overlay nginx
```

### ğŸ›  Best Practices

| Practice                                       | Why                                           |
| ---------------------------------------------- | --------------------------------------------- |
| Use **user-defined bridge** for microservices  | Enables DNS-based service discovery           |
| Use **overlay** for Swarm deployments          | Required for multi-node networking            |
| Avoid **host mode** unless latency is critical | Host mode bypasses Dockerâ€™s isolation & DNS   |
| Use **network aliases** for legacy systems     | Helps emulate fixed hostnames inside networks |

### ğŸ“Œ When to use which network mode

| Requirement                     | bridge | host | overlay | macvlan | none |
| ------------------------------- | ------ | ---- | ------- | ------- | ---- |
| Multi-container local setup     | âœ…      | âŒ    | âŒ       | âŒ       | âŒ    |
| Multi-node Swarm service        | âŒ      | âŒ    | âœ…       | âš ï¸      | âŒ    |
| Minimal-latency app (e.g., DNS) | âš ï¸     | âœ…    | âŒ       | âŒ       | âŒ    |
| Air-gapped containers (sandbox) | âŒ      | âŒ    | âŒ       | âŒ       | âœ…    |
| Need real IP on LAN             | âŒ      | âŒ    | âŒ       | âœ…       | âŒ    |

---

## ğŸ”¹ 10. Docker Swarm

### ğŸ“Œ What is it?

Docker Swarm is Dockerâ€™s built-in **container orchestration** tool for managing services across multiple nodes (hosts).

### ğŸ”§ What else is used?

| Orchestrator   | Comparison                        |
|----------------|-----------------------------------|
| Kubernetes     | More features, but complex        |
| Nomad          | Simpler, less Docker-native       |

### âœ… Pros

- ğŸ§© Built into Docker CLI
- ğŸ” Rolling updates
- ğŸ” Secure by default (mTLS, RAFT)
- ğŸ§  Simple learning curve

### âŒ Cons

- ğŸ“‰ Limited ecosystem
- â›” Lacks advanced Kubernetes features (CRDs, operators)

### ğŸ“¦ Example

```bash
docker swarm init
docker service create --replicas 3 nginx
```

### ğŸ›  Best Practices

- Use `docker stack deploy` with Compose files
- Secure join tokens
- Use healthchecks and constraints for scheduling

### ğŸ“Œ When to use

| Use Case            | Use Swarm? |
|---------------------|------------|
| Simple prod clusters| âœ… Yes     |
| HA, multi-cloud     | âš ï¸ K8s better |
| Learning orchestration | âœ… Good start |

---

## ğŸ”¹ 11. Stack Files

### ğŸ“Œ What is it?

A Docker Stack file (`docker-compose.yml`) is a YAML-based configuration used with `docker stack deploy` in Swarm mode to define multi-container applications with networking, volumes, and services.

### ğŸ”§ What else is used?

| Tool               | Limitation                      |
|--------------------|----------------------------------|
| `docker run`       | Too verbose for complex setups   |
| Kubernetes YAML    | More powerful, less user-friendly|

### âœ… Pros

- ğŸ§± Declarative and versionable
- ğŸ”— Includes networking, volumes, scaling
- ğŸ“ Familiar to Compose users

### âŒ Cons

- âš ï¸ Not as powerful as Kubernetes specs
- ğŸ“‰ Not compatible with Compose v2 features in all cases

### ğŸ“¦ Example

```yaml
services:
  web:
    image: nginx
    ports:
      - "80:80"
```

### ğŸ›  Best Practices

- Keep services modular
- Use `.env` for secrets/overrides
- Store in Git

### ğŸ“Œ When to use

| Scenario                   | Use Stack File? |
|----------------------------|-----------------|
| Swarm deployment           | âœ… Required     |
| Local dev                  | âš ï¸ Use Compose  |
| Kubernetes environments    | âŒ Use K8s YAML |

---

## ğŸ”¹ 12. Docker Orchestration Options

### ğŸ“Œ What is it?

Container orchestration enables scheduling, scaling, and lifecycle management across multiple hosts.

### ğŸ”§ What else is used?

| Tool          | Pros                           | Cons                        |
|---------------|--------------------------------|-----------------------------|
| Swarm         | Simple, Docker-native          | Limited features            |
| Kubernetes    | Feature-rich, ecosystem        | Complex to manage           |
| Nomad         | Lightweight, multi-runtime     | Less adoption               |

### âœ… Pros of Orchestration

- âš™ï¸ Automated scaling & deployment
- ğŸ”„ Self-healing containers
- ğŸ“¡ Service discovery
- ğŸ›¡ Secure defaults (RBAC, mTLS)

### âŒ Cons

- ğŸ“š Steep learning curve (esp. K8s)
- âš ï¸ More moving parts
- ğŸ’µ Increased operational overhead

### ğŸ“Œ When to use what

| Requirement               | Recommended Tool |
|---------------------------|------------------|
| Simplicity, Docker-native | âœ… Swarm         |
| Enterprise-grade control  | âœ… Kubernetes     |
| Minimalist multi-runtime  | âœ… Nomad          |

### ğŸ§  Addendum: `docker node update --availability`: Control Node Scheduling Status in Docker Swarm

This command is used to **manually change the availability of a Swarm node**, affecting whether the node is eligible to run tasks (containers).

#### ğŸ“Œ Syntax

```bash
docker node update --availability <availability-option> <node-name>
```

#### ğŸ” Available Options

|Option|Description|Use Case Example|
|---|---|---|
|`active`|Node is fully operational and **can receive new tasks**.|Default state. Use when the node is healthy and should participate in the swarm.|
|`pause`|Node **does not receive new tasks**, but keeps running existing tasks.|Use during maintenance where you donâ€™t want new tasks, but donâ€™t want disruption.|
|`drain`|Node **stops all tasks** and **migrates them** to other active nodes.|Use before shutting down or restarting a node to prevent downtime.|

#### âš™ï¸ Example Commands

- Drain a node for safe shutdown:
    
    ```bash
    docker node update --availability drain docker02
    ```
    
- Resume task scheduling on a node:
    
    ```bash
    docker node update --availability active docker02
    ```
    
- Pause a node temporarily (no new tasks, keep current ones):
    
    ```bash
    docker node update --availability pause docker02
    ```
    

#### ğŸ›ï¸ Best Practices

- Use `drain` before performing OS updates or hardware maintenance to **avoid service interruptions**.
    
- Use `pause` when troubleshooting but want services to remain temporarily running.
    
- Always switch back to `active` when the node is ready to **rejoin the swarm scheduling pool**.

---

## ğŸ”¹ 13. Replicated vs Global Services

### ğŸ“Œ What is it?

In Swarm, services can be deployed as:

- **Replicated**: X copies across nodes
- **Global**: 1 copy per node

### ğŸ”§ What else is used?

| Mode      | Purpose                     |
|-----------|-----------------------------|
| Replicated| Scale apps like web servers |
| Global    | Per-host tasks like logging |

### âœ… Pros

- ğŸ“Š Predictable deployment
- âš™ï¸ Suitable for scaling or host-specific agents

### âŒ Cons

- âš ï¸ Global services canâ€™t scale arbitrarily
- ğŸ§  Replicated mode needs resource planning

### ğŸ“¦ Example

```yaml
deploy:
  mode: global
```

### ğŸ“Œ When to use

| Scenario                | Replicated | Global |
|-------------------------|------------|--------|
| Web/API servers         | âœ… Yes     | âŒ No  |
| Node exporter/log agent | âŒ No      | âœ… Yes |

---

## ğŸ”¹ 14. Docker Services / Templates

### ğŸ“Œ What is it?

In Swarm, a **service** is a long-running container definition. Templates allow dynamic substitution of environment variables, labels, or constraints.

### ğŸ”§ What else is used?

| Alternative   | Drawback                           |
|----------------|------------------------------------|
| Manual containers | No scale/healthcheck built-in   |
| Compose only      | Local or single-host only       |

### âœ… Pros

- â™»ï¸ Stateless or stateful scaling
- ğŸ§© Integrated with Swarm features
- ğŸ§  Template logic for dynamic configuration

### âŒ Cons

- âš ï¸ Learning curve for templating
- â›” No support outside Swarm

### ğŸ“¦ Example

```bash
docker service create --name web --replicas 3 nginx
```

### ğŸ›  Best Practices

- Use constraints and placement
- Use healthchecks and limits
- Template secrets/configs via Swarm

### ğŸ“Œ When to use

| Use Case                  | Use Service? |
|---------------------------|--------------|
| Cluster deployment        | âœ… Yes       |
| One-off job or init task  | âŒ Use job   |
| Stateful scaling          | âš ï¸ With volumes |

---

## ğŸ”¹ 15. Registries

### ğŸ“Œ What is it?

A Docker Registry stores and distributes Docker images. Docker Hub is the default public registry, while private registries can be hosted internally (e.g. Harbor, Artifactory, AWS ECR).

### ğŸ”§ What else is used?

| Alternative       | Limitation                        |
|-------------------|------------------------------------|
| File shares       | No image versioning or tagging     |
| CI/CD artifacts   | No native Docker integration       |

### âœ… Pros

- ğŸ“¦ Centralized image storage
- ğŸ” Version control with tags
- ğŸ” Access control in private registries

### âŒ Cons

- â›” Rate limiting (Docker Hub)
- ğŸ›¡ Requires TLS for secure setups

### ğŸ“¦ Example

```bash
docker pull myregistry.local/myimage:1.0
```

### ğŸ›  Best Practices

- Use private registries for production
- Set up authentication & TLS
- Clean up unused images regularly

### ğŸ“Œ When to use

| Context                 | Registry Type         |
|--------------------------|------------------------|
| Public open-source apps  | âœ… Docker Hub          |
| Enterprise applications  | âœ… Private (Harbor, ECR) |

---

## ğŸ”¹ 16. Docker Engine, UCP, DTR

### ğŸ“Œ What is it?

- **Docker Engine**: Core runtime for building/running containers
- **UCP (Universal Control Plane)**: GUI + RBAC management for Docker EE
- **DTR (Docker Trusted Registry)**: Enterprise-grade image registry with scanning, signing

### ğŸ”§ What else is used?

| Component | Alternative                   |
|----------|--------------------------------|
| UCP      | Portainer, Kubernetes Dashboard|
| DTR      | Harbor, Artifactory, ECR       |

### âœ… Pros

- ğŸ›  UCP offers secure cluster management
- ğŸ” DTR includes image scanning, RBAC
- ğŸ“ˆ Enterprise-grade integrations

### âŒ Cons

- ğŸ’µ Requires Docker Enterprise license
- ğŸ“š Learning curve for GUI/RBAC

### ğŸ“Œ When to use

| Feature Needed         | Use Engine/UCP/DTR? |
|------------------------|---------------------|
| Basic Docker runtime   | âœ… Engine only      |
| Secure GUI for Swarm   | âœ… UCP             |
| Internal image control | âœ… DTR             |

---

## ğŸ”¹ 17. Overlay Network

### ğŸ“Œ What is it?

An **overlay network** spans multiple Docker hosts, enabling containers on different nodes to communicate securely over a virtual network.

### ğŸ”§ What else is used?

| Option       | Limitation                              |
|--------------|------------------------------------------|
| Bridge network | Local to one host only                 |
| Host network   | No isolation, high port conflict risk  |

### âœ… Pros

- ğŸŒ Multi-host communication
- ğŸ”’ Encrypted by default in Swarm
- ğŸ§  Built-in service discovery

### âŒ Cons

- ğŸ“¶ Requires cluster setup
- ğŸ§µ Adds networking complexity

### ğŸ“¦ Example

```bash
docker network create -d overlay mynet
```

### ğŸ›  Best Practices

- Use for Swarm services
- Name networks clearly
- Monitor MTU and latency issues

### ğŸ“Œ When to use

| Scenario                   | Use Overlay? |
|----------------------------|--------------|
| Cross-node communication   | âœ… Yes       |
| Local-only app             | âŒ Use bridge|
| Swarm deployments          | âœ… Required  |

---

## ğŸ”¹ 18. Host vs Ingress Publishing Modes

### ğŸ“Œ What is it?

In Docker Swarm, services can publish ports using:

- **Host Mode**: Maps ports directly to each node
- **Ingress Mode**: Uses routing mesh to distribute traffic across nodes

### ğŸ”§ What else is used?

| Mode     | Behavior                              |
|----------|----------------------------------------|
| Host     | Node-local access                     |
| Ingress  | Load-balancing across all nodes       |

### âœ… Pros

**Host**:
- ğŸ”„ Direct traffic control
- âš¡ Lower latency

**Ingress**:
- ğŸŒ Auto load-balancing
- âœ… Works without external LB

### âŒ Cons

**Host**:
- âš ï¸ Manual IP mapping per node

**Ingress**:
- ğŸ” Less transparent routing
- ğŸ›  Difficult to debug under load

### ğŸ“¦ Example

```yaml
ports:
  - target: 80
    published: 8080
    mode: host
```

### ğŸ“Œ When to use

| Use Case                   | Host | Ingress |
|----------------------------|------|---------|
| Low-latency gaming         | âœ…    | âŒ      |
| Generic web service        | âš ï¸    | âœ…      |
| Custom load balancing      | âœ…    | âš ï¸      |


## ğŸ”¹ 19. Storage Drivers (overlay2, devicemapper)

### ğŸ“Œ What is it?

Storage drivers manage how Docker stores images and container layers on disk. Common drivers include `overlay2`, `aufs`, `devicemapper`, and `btrfs`.

### ğŸ”§ What else is used?

| Alternative     | Limitation                              |
|------------------|------------------------------------------|
| Loopback mounts  | Poor performance, not production-grade   |
| LVM/Bare disk    | Complex setup                           |

### âœ… Pros

- âš¡ Fast layer management (`overlay2`)
- ğŸ§± Efficient reuse of base layers
- ğŸ”„ Snapshot-like layer structure

### âŒ Cons

- âš ï¸ Incompatible drivers on some distros
- â›” Can be hard to clean up disk usage

### ğŸ“Œ When to use

| Driver         | Best For                              |
|----------------|----------------------------------------|
| overlay2       | âœ… Default for modern Linux            |
| devicemapper   | âš ï¸ Legacy, slow for many small files   |

---

## ğŸ”¹ 20. Block/Object Storage Use-Cases

### ğŸ“Œ What is it?

Containers may rely on external **block** (e.g., EBS, iSCSI) or **object** (e.g., S3, MinIO) storage for persistence, backups, or application data.

### ğŸ”§ What else is used?

| Storage Type | Features               | Limitation                   |
|--------------|------------------------|------------------------------|
| Block        | Filesystem-level access| âš ï¸ Tight host dependency     |
| Object       | API-driven access      | âŒ No POSIX file operations  |

### âœ… Pros

- ğŸ” Object storage is scalable and cheap
- ğŸ”’ Block storage is fast and reliable

### âŒ Cons

- âš ï¸ Object storage must be integrated via apps or middleware
- ğŸ§± Block storage is tightly coupled to host

### ğŸ“Œ When to use

| Use Case             | Block | Object |
|----------------------|-------|--------|
| Databases            | âœ… Yes| âŒ No   |
| Backups              | âŒ No | âœ… Yes  |
| Distributed apps     | âš ï¸ Varies | âœ… Often |

---

## ğŸ”¹ 21. Filesystem Layering and Image Layers

### ğŸ“Œ What is it?

Docker images consist of **read-only layers** stacked on top of each other. The topmost writable layer is created at container runtime.

### ğŸ”§ What else is used?

| Approach         | Limitation                         |
|------------------|-------------------------------------|
| Full image copy  | Inefficient, no reuse               |
| Manual packaging | Hard to maintain                    |

### âœ… Pros

- ğŸ“¦ Layer reuse reduces image size
- ğŸ” Caching speeds up rebuilds
- ğŸ§  Traceability for debugging

### âŒ Cons

- âš ï¸ Bad layer ordering = bloated images
- â›” Difficult to â€œsquashâ€ if needed

### ğŸ“¦ Example

Each `RUN`, `COPY`, or `ADD` = 1 image layer

### ğŸ›  Best Practices

- Place rarely changed commands (e.g. `apt-get`) early
- Reduce layers by chaining `RUN` statements

---

## ğŸ”¹ 22. Cluster Volume Propagation (Kubernetes PV/PVC/CSI)

### ğŸ“Œ What is it?

In Kubernetes (and Docker with plugins), **Persistent Volumes (PV)** and **Persistent Volume Claims (PVC)** abstract storage. CSI (Container Storage Interface) standardizes access to different backends.

### ğŸ”§ What else is used?

| Method          | Limitation                         |
|------------------|-------------------------------------|
| HostPath volumes | Node-local only, no HA             |
| Docker volumes   | Not cluster-aware                  |

### âœ… Pros

- ğŸ“¡ Decouples pods from storage implementation
- ğŸ”„ Supports dynamic provisioning
- â˜ï¸ Integrates with cloud-native storage (EBS, Azure Disk, GCE PD)

### âŒ Cons

- âš ï¸ Steep learning curve
- ğŸ§± Misconfiguration can lead to data loss

### ğŸ“¦ Example

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
...
```

### ğŸ“Œ When to use

| Requirement               | Use PV/PVC/CSI? |
|---------------------------|-----------------|
| Stateless app             | âŒ Not needed   |
| Shared storage            | âœ… Required     |
| Cloud-native HA volumes   | âœ… Required     |


## ğŸ”¹ 23. Swarm Security (Defaults, mTLS, Roles)

### ğŸ“Œ What is it?

Docker Swarm includes built-in security features:
- **Mutual TLS (mTLS)** between nodes
- **Raft encryption**
- **Auto-rotating certificates**
- **Manager/worker roles** for access control

### ğŸ”§ What else is used?

| Tool          | Limitation                      |
|---------------|----------------------------------|
| Kubernetes    | More powerful, harder to set up  |
| Manual TLS    | Prone to misconfiguration        |

### âœ… Pros

- ğŸ” Secure by default
- ğŸ” Automatic certificate rotation
- ğŸ§± Role separation (manager/worker)

### âŒ Cons

- ğŸ§  Limited RBAC
- ğŸ§µ No user-level auth

### ğŸ›  Best Practices

- Limit `manager` role access
- Regularly rotate join tokens
- Disable auto-lock override on sensitive deployments

---

## ğŸ”¹ 24. UCP/DTR Roles, RBAC, LDAP/AD Integration

### ğŸ“Œ What is it?

UCP provides role-based access control (RBAC) for Swarm, integrated with LDAP/Active Directory. DTR (Docker Trusted Registry) can also enforce image-level access control.

### ğŸ”§ What else is used?

| Alternative       | Limitation                          |
|--------------------|--------------------------------------|
| Docker CE only     | No user management or RBAC           |
| External LDAP auth | No container-specific RBAC           |

### âœ… Pros

- ğŸ›¡ Fine-grained access control
- ğŸ‘¥ LDAP/AD integration for identity management
- ğŸ” Audit trails for compliance

### âŒ Cons

- ğŸ§  Learning curve
- ğŸ’µ Enterprise-only feature

### ğŸ“Œ When to use

| Scenario                     | Use UCP/DTR RBAC? |
|------------------------------|-------------------|
| Shared cluster environment   | âœ… Yes            |
| Internal small dev team      | âŒ Not necessary  |
| Regulated environments       | âœ… Critical       |

---

## ğŸ”¹ 25. Image Scanning

### ğŸ“Œ What is it?

Image scanning tools (e.g. Trivy, DTR, Clair) analyze Docker images for known CVEs and vulnerabilities in libraries, base images, and packages.

### ğŸ”§ What else is used?

| Tool       | Notes                        |
|------------|------------------------------|
| Trivy      | Fast, open-source            |
| DTR Scan   | Built into Docker EE         |
| Clair      | Extensible, supports APIs    |

### âœ… Pros

- ğŸ§ª Pre-deployment security analysis
- ğŸ”’ Catch vulnerabilities early
- ğŸ” Automate via CI/CD hooks

### âŒ Cons

- âš ï¸ False positives
- â± Slows down image pipelines

### ğŸ“¦ Example

```bash
trivy image myapp:latest
```

### ğŸ›  Best Practices

- Integrate with CI/CD
- Scan both base and custom layers
- Track vulnerabilities over time



## ğŸ›¡ï¸ Addendum: Docker Bench for Security

A shell script maintained by Docker Inc. that **automates CIS Docker Benchmark checks** to assess Docker host and container security in production.

### ğŸ” What It Does

- Scans host and container configurations for common security issues (e.g., config files, daemon settings, host partitioning, runtime hardening)
    
- Reports findings as **PASS**, **WARN**, **INFO**, or **NOTE**
    
- Calculates an overall **security â€œscoreâ€** based on PASS results
    

---

### âš™ï¸ Installation & Execution

#### Run Locally

```bash
git clone https://github.com/docker/docker-bench-security.git
cd docker-bench-security
sudo sh docker-bench-security.sh
```

#### Run via Docker

```bash
docker run --rm \
  --net host --pid host --userns host \
  --cap-add audit_control \
  -e DOCKER_CONTENT_TRUST=$DOCKER_CONTENT_TRUST \
  -v /etc:/etc:ro \
  -v /usr/bin/containerd:/usr/bin/containerd:ro \
  -v /usr/bin/runc:/usr/bin/runc:ro \
  -v /usr/lib/systemd:/usr/lib/systemd:ro \
  -v /var/lib:/var/lib:ro \
  -v /var/run/docker.sock:/var/run/docker.sock:ro \
  --label docker_bench_security \
  docker/docker-bench-security
```

> âš ï¸ Adjust mounted volumes based on your OS and container runtime.

---

### ğŸ“Š CLI Options

```
-b           Disable colored output  
-h           Print help  
-l FILE      Log output to FILE (inside container)  
-u USERS     Comma-separated list of trusted docker users  
-c CHECK     Run only the specified check(s) (e.g., check_2_2)  
-e CHECK     Exclude the specified check(s)  
-i INCLUDE   Only check containers/images matching patterns  
-x EXCLUDE   Exclude containers/images matching patterns  
-t LABEL     Only check containers/images with these labels  
-n LIMIT     In JSON output, limit array lengths (0 = no limit)  
-p PRINT     Skip printing remediation advice
```

**Examples:**

- Run a specific CIS check:
    
    ```bash
    sh docker-bench-security.sh -c check_2_2
    ```
    
- Exclude a check group:
    
    ```bash
    sh docker-bench-security.sh -e docker_enterprise_configuration
    ```
    
- Include only certain images:
    
    ```bash
    sh docker-bench-security.sh -i nginx,redis
    ```
    

---

### ğŸ“‹ Use Cases

- **Baseline Hardening**: Enforce compliance across production hosts via automated CIS benchmark checks
    
- **CI Integration**: Include as a security gate in deployment pipelines; score serves as quantifiable metric
    
- **On-Demand Audits**: Regularly audit hosts or before major changes
    

---

### âœ… Outputs & Interpretation

- Each test yields a label (`PASS`, `WARN`, `NOTE`, `INFO`)
    
- **WARN** signals configuration issues to prioritize; **NOTE** offers non-critical advice
    
- Final **score** is based on number of PASS results
    

---

### â• Complementary Tools

Pair with:

- **Trivy / Grype / Snyk**: for vulnerability (CVE) scanning inside container images
    
- **Dockle**: for Dockerfile linting and best-practice checks
    
- **Syscalls (Tracee), Dive, auditd**: for runtime auditing, image layering, host-level monitoring

---

## ğŸ”¹ 26. Certificates and Auth

### ğŸ“Œ What is it?

Docker uses TLS certificates for encrypting traffic (client/server, Swarm). Authentication includes:
- Docker Hub login
- TLS mutual auth
- LDAP/AD for UCP

### ğŸ”§ What else is used?

| Method        | Limitation                          |
|----------------|--------------------------------------|
| HTTP API       | Unencrypted without TLS             |
| Username/password only | Insecure without TLS        |

### âœ… Pros

- ğŸ›¡ Encrypted API communication
- ğŸ§¾ Auth to registries and Swarm nodes
- ğŸ” Supports certificate rotation

### âŒ Cons

- âš™ï¸ Manual TLS setup can be error-prone
- ğŸ§  User auth in Docker CE is limited

### ğŸ“Œ When to use

| Use Case                        | Require Cert/Auth? |
|----------------------------------|---------------------|
| Internet-exposed Docker APIs     | âœ… Always           |
| Local-only dev cluster           | âš ï¸ Optional         |
| Registry push/pull in prod       | âœ… Yes              |

## ğŸ”¹ 27. Namespaces / cgroups

### ğŸ“Œ What is it?

Docker relies on **Linux namespaces** and **control groups (cgroups)** to provide isolation and resource control:

- **Namespaces**: Isolate process ID, network, mount, UTS, IPC
- **Cgroups**: Control CPU, memory, I/O usage per container

### ğŸ”§ What else is used?

| Method          | Drawback                        |
|------------------|----------------------------------|
| Full VMs         | Higher overhead, slower boot    |
| AppArmor/SELinux | Security only, not isolation    |

### âœ… Pros

- ğŸ§© Strong process separation
- âš™ï¸ Fine-grained resource limiting
- ğŸ” Shared-kernel but isolated workloads

### âŒ Cons

- ğŸ§  Complex to debug
- â— Kernel bugs could impact all containers

### ğŸ“Œ When to use

| Feature Needed         | Use namespaces/cgroups? |
|------------------------|--------------------------|
| Container isolation     | âœ… Always               |
| Dedicated physical hosts| âŒ Optional             |

---

## ğŸ”¹ 28. Backup Strategies

### ğŸ“Œ What is it?

Backing up containerized apps typically involves backing up:

- Named volumes (binds, persistent data)
- Container configurations (Compose, Stack files)
- Registry images

### ğŸ”§ What else is used?

| Method          | Limitation                        |
|------------------|----------------------------------|
| Host backup      | Misses container metadata         |
| Manual `tar`     | Not scalable                      |

### âœ… Pros

- ğŸ§± Restorable services from code + data
- ğŸ”„ Versionable configuration

### âŒ Cons

- ğŸ“¦ Volume-only backup may miss secrets/configs
- ğŸ§  Restore process must be tested

### ğŸ›  Best Practices

- Backup volumes using `docker cp`, `rsync`, or `restic`
- Store Compose/Stack files in version control
- Backup registry if self-hosted

---

## ğŸ”¹ 29. Image Signing Lifecycle

### ğŸ“Œ What is it?

Docker image signing ensures authenticity and integrity of images via tools like **Notary** (v1) or **cosign** (v2+), often used in Secure Supply Chains.

### ğŸ”§ What else is used?

| Tool     | Description                           |
|----------|----------------------------------------|
| Notary   | Legacy Docker Content Trust system     |
| cosign   | CNCF project for modern signing        |
| Sigstore | Open ecosystem for secure builds       |

### âœ… Pros

- ğŸ” Validates publisher identity
- ğŸ“¦ Protects against tampering
- ğŸ”„ Chain of trust via CI/CD

### âŒ Cons

- ğŸ§  Manual key management complexity
- ğŸ§ª Not universally enforced (unless integrated)

### ğŸ“Œ When to use

| Context                      | Use Image Signing? |
|------------------------------|---------------------|
| Production deployments       | âœ… Yes              |
| Internal dev images          | âš ï¸ Optional         |
| Public image distribution    | âœ… Critical         |

## ğŸ§  Docker DCA Exam Tips (Callouts)

These callouts are short facts and reminders designed to help you prepare for the Docker Certified Associate (DCA) exam. Place them as side-notes or ğŸ§  tip boxes in your markdown files or README guides.

---

### âœ… General

- âœ… Understand that Docker containers share the host kernel (unlike VMs).
- âœ… Images are built from the bottom up; layers are cached unless invalidated.
- âœ… Default network mode for user-defined networks isÂ **bridge**, and DNS is enabled.

---

### ğŸ”¹ Storage & Volumes

- âœ…Â `overlay2`Â is the default storage driver on most modern Linux distros.
- âœ… Bind mounts depend on host paths and can lead to portability issues.
- âœ… Named volumes are managed by Docker and persist even after container deletion.

---

### ğŸ”¹ Dockerfiles & Builds

- âœ… Each instruction in a Dockerfile creates a new image layer.
- âœ… Best practice: UseÂ `.dockerignore`Â to reduce build context size.
- âœ… UseÂ `--no-cache`Â if you want to skip layer cache during builds.

---

### ğŸ”¹ Container Runtime

- âœ… PID 1 in a container must handle signals correctly (trap SIGTERM).
- âœ… UseÂ `tini`Â orÂ `dumb-init`Â to avoid zombie processes.

---

### ğŸ”¹ Networking

- âœ…Â `bridge`Â is the default driver for containers on a single host.
- âœ…Â `host`Â network shares the host stack â€” no isolation.
- âœ…Â `overlay`Â networks enable multi-host communication (Swarm).

---

### ğŸ”¹ Swarm & Orchestration

- âœ…Â `docker swarm init`Â promotes a node to manager.
- âœ… Swarm usesÂ **mTLS**Â andÂ **Raft**Â consensus for secure clustering.
- âœ… Global services run one task per node; replicated services scale arbitrarily.

---

### ğŸ”¹ Registry & Image Signing

- âœ… Docker Hub has pull rate limits for unauthenticated users.
- âœ… UseÂ `cosign`Â or Docker Content Trust (DCT) for signing and verification.

---

### ğŸ”¹ Security

- âœ… Trivy scans both OS packages and app dependencies.
- âœ… You must secure Docker API with TLS in production environments.
- âœ… UCP supports LDAP and RBAC, but is part of Docker Enterprise.

---

### ğŸ”¹ Kubernetes Integration (For Volume Topics)

- âœ… Kubernetes uses PersistentVolume (PV) and PersistentVolumeClaim (PVC) for dynamic storage binding.
- âœ… CSI (Container Storage Interface) is the standard for storage drivers in K8s.

---

### ğŸ”¹ Monitoring, Logs, and Backup

- âœ…Â `docker logs`Â only shows stdout/stderr â€” no access logs.
- âœ… Use log drivers (e.g. json-file, syslog) to ship logs externally.
- âœ… Backup volumes withÂ `docker cp`,Â `rsync`, or third-party tools likeÂ `restic`.


## â˜¢ Lab Tasks

| Tech           | Lab Task                                                                       | Goal                                                     | Tooling/Env                          |
| -------------- | ------------------------------------------------------------------------------ | -------------------------------------------------------- | ------------------------------------ |
| **Docker**     | âœ… Compare Docker vs VMs by creating both a VM and a container for the same app | Understand Dockerâ€™s performance & portability advantages | Docker Desktop, VirtualBox           |
| **Docker**     | âœ… Write a Dockerfile for a simple Python/Flask app                             | Learn how to package an app into a portable image        | Docker Desktop or Linux + Docker CLI |
| **Docker**     | âœ… Use `docker build` to tag and build your image with versioning               | Master image build workflow                              | Docker CLI                           |
| **Docker**     | âœ… Run container in both detached and interactive modes                         | Learn run-time flags and modes                           | Docker CLI                           |
| **Docker**     | âœ… Capture logs from running container                                          | Understand ephemeral logs and logging limits             | Docker CLI                           |
| **Docker**     | âœ… Use `docker inspect` and `docker ps` with format filters                     | Gain debugging and automation skills                     | Docker CLI + jq                      |
| **Docker**     | âœ… Run a container with PID 1 as a shell script vs `tini`                       | Test how signal handling differs in containers           | Docker CLI                           |
| **Docker**     | âœ… Use named volumes to persist a SQLite DB                                     | Practice managing persistent data                        | Docker + Docker volumes              |
| **Docker**     | âœ… Connect multiple containers over a custom bridge network                     | Test inter-container communication and DNS resolution    | Docker Compose or CLI                |
| **Docker**     | âœ… Init a Swarm and deploy a replicated service                                 | Get hands-on with Swarm basics                           | Docker Swarm Mode                    |
| **Docker**     | âœ… Write and deploy a `docker-compose.yml` as a stack                           | Define and manage multi-service apps                     | Swarm Mode + Compose v3              |
| **Docker**     | âœ… Create both replicated and global services                                   | Compare use cases and behavior                           | Docker Swarm                         |
| **Docker**     | âœ… Use placement constraints and healthchecks                                   | Control where and how services run                       | Swarm YAML + CLI                     |
| **Docker**     | âœ… Push/pull image to Docker Hub and private registry                           | Learn image versioning and publishing                    | Docker Hub, optional local registry  |
| **Docker**     | âœ… Create and test overlay network across two Swarm nodes                       | Practice multi-host networking                           | 2-node Swarm (local or cloud)        |
| **Docker**     | âœ… Deploy services with both `host` and `ingress` publish modes                 | Understand routing mesh vs direct bind                   | Swarm CLI                            |
| **Docker**     | âœ… Use `docker info` to identify your storage driver                            | Know how your system stores container data               | Docker CLI                           |
| **Docker**     | âœ… Compare image sizes based on Dockerfile layer order                          | Optimize layering strategy                               | Docker build                         |
| **Kubernetes** | âœ… Create a PersistentVolume and PVC, mount in pod                              | Learn cluster-wide volume mapping                        | Minikube or Rancher Desktop          |
| **Docker**     | âœ… Inspect mTLS settings in a Swarm cluster                                     | Understand Dockerâ€™s default encryption model             | Docker Swarm                         |
| **Docker**     | âœ… Simulate user access with UCP and LDAP or dummy users                        | Test fine-grained access control                         | Docker EE / UCP                      |
| **Docker**     | âœ… Scan image with Trivy in CI or locally                                       | Catch vulnerabilities early                              | Trivy + Docker                       |
| **Docker**     | âœ… Limit container resources with `--memory` and `--cpus`                       | Use cgroups to simulate resource-limited environments    | Docker CLI                           |
| **Docker**     | âœ… Backup and restore a named volume with `docker cp`                           | Master basic backup workflows                            | Docker CLI + host filesystem         |
| **Docker**     | âœ… Sign and verify an image using cosign                                        | Implement a basic image trust chain                      | cosign + Docker                      |
